<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>leetcode weekly contest 155 | Drowning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1200. Minimum Absolute Difference问题给定一个由多个不同数字组成的数组，返回所有的绝对差最小的数字对。 输入：arr = [4,2,1,3]输出：[[1,2],[2,3],[3,4]] 思路先对数组元素排序，然后计算所有相邻元素的绝对差，取最小的差对应的数字对。第一种方法用了额外的空间存储绝对差和对应的数字对。 1234567891011121314class So">
<meta name="keywords" content="leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode weekly contest 155">
<meta property="og:url" content="http://woodsouths.github.io/2019/09/23/155/index.html">
<meta property="og:site_name" content="Drowning">
<meta property="og:description" content="1200. Minimum Absolute Difference问题给定一个由多个不同数字组成的数组，返回所有的绝对差最小的数字对。 输入：arr = [4,2,1,3]输出：[[1,2],[2,3],[3,4]] 思路先对数组元素排序，然后计算所有相邻元素的绝对差，取最小的差对应的数字对。第一种方法用了额外的空间存储绝对差和对应的数字对。 1234567891011121314class So">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-09-24T15:39:15.611Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leetcode weekly contest 155">
<meta name="twitter:description" content="1200. Minimum Absolute Difference问题给定一个由多个不同数字组成的数组，返回所有的绝对差最小的数字对。 输入：arr = [4,2,1,3]输出：[[1,2],[2,3],[3,4]] 思路先对数组元素排序，然后计算所有相邻元素的绝对差，取最小的差对应的数字对。第一种方法用了额外的空间存储绝对差和对应的数字对。 1234567891011121314class So">
  
    <link rel="alternate" href="/atom.xml" title="Drowning" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Drowning</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://woodsouths.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-155" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/23/155/" class="article-date">
  <time datetime="2019-09-23T02:44:26.000Z" itemprop="datePublished">2019-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      leetcode weekly contest 155
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1200-Minimum-Absolute-Difference"><a href="#1200-Minimum-Absolute-Difference" class="headerlink" title="1200. Minimum Absolute Difference"></a>1200. Minimum Absolute Difference</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给定一个由多个不同数字组成的数组，返回所有的绝对差最小的数字对。</p>
<p>输入：arr = [4,2,1,3]<br>输出：[[1,2],[2,3],[3,4]]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先对数组元素排序，然后计算所有相邻元素的绝对差，取最小的差对应的数字对。<br>第一种方法用了额外的空间存储绝对差和对应的数字对。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span><span class="params">(self, arr: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        diff_pair = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">            diff = arr[i+<span class="number">1</span>] - arr[i]</span><br><span class="line">            diff_pair[diff].append([arr[i], arr[i+<span class="number">1</span>]])</span><br><span class="line">        min_diff = float(<span class="string">'inf'</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> diff_pair.items():</span><br><span class="line">            <span class="keyword">if</span> k &lt; min_diff:</span><br><span class="line">                min_diff = k</span><br><span class="line">                res = diff_pair[min_diff]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>也可以先计算最小的数字对，然后再扫描一遍数组，找到最小的绝对差对应的数字对。（这个实现用了zip，看上去非常简洁）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span><span class="params">(self, arr: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        min_diff = min(b - a <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(arr, arr[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">return</span> [[a, b] <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(arr, arr[<span class="number">1</span>:]) <span class="keyword">if</span> b - a == min_diff]</span><br></pre></td></tr></table></figure>

<h2 id="1201-Ugly-Number-III"><a href="#1201-Ugly-Number-III" class="headerlink" title="1201. Ugly Number III"></a>1201. Ugly Number III</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>给定n, a, b, c，求第n个丑数。丑数的定义是能够被a或b或c整除的数字。（1 &lt;= n, a, b, c &lt;= 10^9， 1 &lt;= a * b * c &lt;= 10^18，[1, 2 * 10^9]）</p>
<p>输入：n = 3, a = 2, b = 3, c = 5<br>输出：4</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>二分搜索，从1～2*10^9开始二分，计算1～当前元素中丑数的个数（计算方式可以用三个集合的交并来考虑）。（具体思路参考：<a href="https://leetcode.com/problems/ugly-number-iii/discuss/387561/Short-and-Concise-C%2B%2B-Solution-(Binary-Search)-with-explanation）" target="_blank" rel="noopener">https://leetcode.com/problems/ugly-number-iii/discuss/387561/Short-and-Concise-C%2B%2B-Solution-(Binary-Search)-with-explanation）</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int, a: int, b: int, c: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lcm</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i * j // math.gcd(i, j)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">num_division_under</span><span class="params">(n, a, b, c)</span>:</span></span><br><span class="line">            l1 = lcm(a, b)</span><br><span class="line">            l2 = lcm(b, c)</span><br><span class="line">            l3 = lcm(a, c)</span><br><span class="line">            l4 = lcm(l1, l2)</span><br><span class="line">            <span class="keyword">return</span> n // a + n // b + n // c - n // l1 - n // l2 - n // l3 + n // l4</span><br><span class="line">        </span><br><span class="line">        lo, hi = <span class="number">1</span>, <span class="number">2</span> * <span class="number">10</span> ** <span class="number">9</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            num = num_division_under(mid, a, b, c)</span><br><span class="line">            <span class="keyword">if</span> num == n:</span><br><span class="line">                ans = mid</span><br><span class="line">                hi = hi - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; n:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>这里要注意的是当num == n时不能直接返回，因为在第n个丑数 - 第n+1个丑数计算出num都等于n，因此需要往前找，找到第一个恰好等于n的，即为第n个丑数。</p>
<h2 id="1202-Smallest-String-With-Swaps"><a href="#1202-Smallest-String-With-Swaps" class="headerlink" title="1202. Smallest String With Swaps"></a>1202. Smallest String With Swaps</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>给定一个字符串和一个二元索引数组，假设这些二元索引对应的字符可以交换任意次，求交换能够得到的最小字典序的字符。</p>
<p>输入：s = “dcab”, pairs = [[0,3],[1,2]]<br>输出： “bacd”</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>将这些二元索引数组看成一张图，这张图有多个连通分量，先给出结论：每个连通分量的索引对应的字符可以交换成任意顺序，而不同连同分量之间的索引对应的字符无法<br>交换。那么只要将每个连通分量内的索引字符交换成最小字典序，则得到了交换能够得到的最小字典序的字符。（具体证明可以参考：<a href="https://leetcode.com/problems/smallest-string-with-swaps/discuss/387618/ChineseC%2B%2B-1202" target="_blank" rel="noopener">https://leetcode.com/problems/smallest-string-with-swaps/discuss/387618/ChineseC%2B%2B-1202</a>. ）</p>
<p>那么具体思路为：</p>
<ul>
<li>根据二元索引构建图</li>
<li>在同一连通分量内，对索引对应的字符排序，然后按索引的顺序从小到大赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[node]:</span><br><span class="line">                visited[node] = <span class="literal">True</span></span><br><span class="line">                index_list.append(node)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    dfs(i)</span><br><span class="line">               </span><br><span class="line">        visited = [<span class="literal">False</span>] * len(s)</span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> pairs:</span><br><span class="line">            graph[i].append(j)</span><br><span class="line">            graph[j].append(i)</span><br><span class="line">        res = list(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> visited[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            index_list = []</span><br><span class="line">            dfs(i)</span><br><span class="line">            index_list.sort()</span><br><span class="line">            char_list = [s[i] <span class="keyword">for</span> i <span class="keyword">in</span> index_list]</span><br><span class="line">            char_list.sort()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(index_list)):</span><br><span class="line">                idx = index_list[i]</span><br><span class="line">                char = char_list[i]</span><br><span class="line">                res[idx] = char</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>

<p>这个数据结构很自然的想到可以用并查集来维护连通图，因此也可以用并查集来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.par = list(range(n))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i != self.par[i]:</span><br><span class="line">            self.par[i] = self.find(self.par[i])</span><br><span class="line">        <span class="keyword">return</span> self.par[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        self.par[self.find(i)] = self.find(j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        l = len(s)</span><br><span class="line">        uf = UF(l)</span><br><span class="line">        candidate = collections.defaultdict(list)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> pairs:</span><br><span class="line">            uf.union(i, j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            candidate[uf.find(i)].append(s[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> candidate.items():</span><br><span class="line">            v.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            res.append(candidate[uf.find(i)].pop())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>

<h2 id="1203-Sort-Items-by-Groups-Respecting-Dependencies"><a href="#1203-Sort-Items-by-Groups-Respecting-Dependencies" class="headerlink" title="1203. Sort Items by Groups Respecting Dependencies"></a>1203. Sort Items by Groups Respecting Dependencies</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>给定n个item，属于m个group，group[n]表示item对应的group，为-1时表示不属于任何group，要求属于同一个group的items连续。beforeItems[n]表示item要求<br>在其之前的items，也就是说对于i，beforeItems[i]中的元素必须要i之前。返回满足上述两个要求的item的一个排列。</p>
<p>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]<br>输出：[6,3,4,1,5,2,0,7]</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>典型的拓扑排序（入度为0时删除节点加入序列，并将节点指向的点入度减一，最后得到的序列如果和节点数相等，那么就得到一个拓扑排序，否则不存在），加上group的要求之后，可以考虑分两个拓扑排序：1）对于group之间的依赖关系；2）group内的依赖关系。</p>
<p>那么具体思路为：</p>
<ul>
<li>根据group，构建group和items的关系。（为-1时为单独一个group）</li>
<li>根据beforeItems构建group间和group内部的依赖关系（图，graph[i][j]和to[j]）</li>
<li>两个拓扑排序，根据group间的拓扑顺序，进行group内的拓扑排序）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortItems</span><span class="params">(self, n: int, m: int, group: List[int], beforeItems: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        no_group = m</span><br><span class="line">        group_items = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            g = group[i]</span><br><span class="line">            <span class="keyword">if</span> g == <span class="number">-1</span>:</span><br><span class="line">                group_items[no_group].append(i)</span><br><span class="line">                group[i] = no_group</span><br><span class="line">                no_group += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                group_items[g].append(i)</span><br><span class="line">        group_dep, item_dep = collections.defaultdict(list), collections.defaultdict(list)</span><br><span class="line">        group_to, item_to = [<span class="number">0</span>] * no_group, [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(beforeItems)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> beforeItems[i]:</span><br><span class="line">                group_no_to = group[i]</span><br><span class="line">                group_no_from = group[j]</span><br><span class="line">                <span class="keyword">if</span> group_no_from != group_no_to:</span><br><span class="line">                    group_dep[group_no_from].append(group_no_to)</span><br><span class="line">                    group_to[group_no_to] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    item_dep[j].append(i)</span><br><span class="line">                    item_to[i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># group topo sort</span></span><br><span class="line">        queue, group_res = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(no_group):</span><br><span class="line">            <span class="keyword">if</span> group_to[i] == <span class="number">0</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">                group_to[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i = queue.pop()</span><br><span class="line">            group_res.append(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> group_dep[i]:</span><br><span class="line">                group_to[j] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> group_to[j] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(j)</span><br><span class="line">        <span class="keyword">if</span> len(group_res) &lt; no_group:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># item topo sort</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> group_res:</span><br><span class="line">            queue = []</span><br><span class="line">            temp = []</span><br><span class="line">            items = group_items[g]</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">                <span class="keyword">if</span> item_to[i] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(i)</span><br><span class="line">                    item_to[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                i = queue.pop(<span class="number">0</span>)</span><br><span class="line">                res.append(i)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> item_dep[i]:</span><br><span class="line">                    item_to[j] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> item_to[j] == <span class="number">0</span>:</span><br><span class="line">                        queue.append(j)</span><br><span class="line">            <span class="keyword">if</span> count &lt; len(items):</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>（写起来挺烦的，注意：beforeItems[i]增加的是i的入度，做item的拓扑排序需要根据group拓扑排序的顺序，每次做完拓扑排序时检查序列大小）<br>还有一个做法，给每个group加源点和会点，对于不同组的依赖加在源点和会点上，这样就可以不用做两次拓扑排序（然而写起来也没有简单多少==）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortItems</span><span class="params">(self, n: int, m: int, group: List[int], beforeItems: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        no_group = m</span><br><span class="line">        group_items = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> group[i] == <span class="number">-1</span>:</span><br><span class="line">                group[i] = no_group</span><br><span class="line">                group_items[no_group].append(i)</span><br><span class="line">                no_group += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                group_items[group[i]].append(i)</span><br><span class="line">        item_dep = collections.defaultdict(list)</span><br><span class="line">        item_tos = [<span class="number">0</span>] * (n + <span class="number">2</span>*m)</span><br><span class="line">        <span class="comment"># add two additiional nodes for all groups whose length &gt; 1</span></span><br><span class="line">        no_node = n</span><br><span class="line">        group_s_e = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> len(group_items[i]) &gt; <span class="number">1</span>:</span><br><span class="line">                s, e = no_node, no_node+<span class="number">1</span></span><br><span class="line">                group_s_e[i].append(s)</span><br><span class="line">                group_s_e[i].append(e)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> group_items[i]:</span><br><span class="line">                    item_dep[s].append(j)</span><br><span class="line">                    item_tos[j] += <span class="number">1</span></span><br><span class="line">                    item_dep[j].append(e)</span><br><span class="line">                item_tos[e] += len(group_items[i])</span><br><span class="line">                no_node += <span class="number">2</span></span><br><span class="line">        <span class="comment"># build item dependency</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> beforeItems[i]:</span><br><span class="line">                g1, g2 = group[i], group[j]</span><br><span class="line">                i_, j_ = i, j</span><br><span class="line">                <span class="keyword">if</span> g1 != g2:</span><br><span class="line">                    <span class="keyword">if</span> group_s_e[g1]:</span><br><span class="line">                        i_ = group_s_e[g1][<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> group_s_e[g2]:</span><br><span class="line">                        j_ = group_s_e[g2][<span class="number">1</span>]</span><br><span class="line">                item_dep[j_].append(i_)</span><br><span class="line">                item_tos[i_] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># topo sort</span></span><br><span class="line">        queue, res = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(no_node):</span><br><span class="line">            <span class="keyword">if</span> item_tos[i] == <span class="number">0</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i = queue.pop()</span><br><span class="line">            item_tos[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; n:</span><br><span class="line">                res.append(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> item_dep[i]:</span><br><span class="line">                item_tos[j] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> item_tos[j] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(res) == n:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>注意：这两种写法实际上在构造group和group之间的依赖关系时其实都有可能构造重复的边，但是对拓扑来说没关系，因为在出i时会将i指向的所有边的删除，所以有重边对拓扑排序是没有影响的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://woodsouths.github.io/2019/09/23/155/" data-id="ck14ormja0006m654otf36570" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/09/19/154/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">leetcode weekly contest 154</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/23/155/">leetcode weekly contest 155</a>
          </li>
        
          <li>
            <a href="/2019/09/19/154/">leetcode weekly contest 154</a>
          </li>
        
          <li>
            <a href="/2019/09/08/153/">leetcode weekly contest 153</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 RC<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>